
name: PR-only Changelog (no tags)

on:
  push:
    branches:
      - main  # or your default branch

permissions:
  contents: write
  pull-requests: read

jobs:
  build-changelog:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Node (for github-script)
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Build PR-only changelog for this push
        id: changelog
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const head = context.sha;
            const before = context.payload.before; // sha before this push

            // If this is the first push (before is all-zero), fallback to first commit on the branch
            let base = before && !/^0+$/.test(before)
              ? before
              : null;

            if (!base) {
              // Find the first commit on default branch
              const branch = context.ref.replace('refs/heads/', '');
              // We need to list commits and take the oldest; the REST API pages by newest first
              // So we walk pages and keep the last seen
              let page = 1, lastSha = null;
              while (true) {
                const res = await github.rest.repos.listCommits({
                  owner, repo,
                  sha: branch,
                  per_page: 100,
                  page
                });
                const commits = res.data;
                if (!commits || commits.length === 0) break;
                lastSha = commits[commits.length - 1].sha;
                if (commits.length < 100) break;
                page++;
              }
              base = lastSha || head + '^'; // fallback to previous commit of head
            }

            core.info(`Comparing commits: ${base}..${head}`);

            const compare = await github.rest.repos.compareCommits({
              owner, repo, base, head
            });

            const commits = compare.data.commits || [];
            core.info(`Found ${commits.length} commits.`);

            // Map PRs that include these commits
            const prMap = new Map();
            for (const c of commits) {
              const sha = c.sha;
              const prs = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner, repo, commit_sha: sha
              });
              for (const pr of prs.data || []) {
                // Only include merged PRs to ensure changes actually landed
                if (pr.merged_at) {
                  if (!prMap.has(pr.number)) {
                    prMap.set(pr.number, {
                      number: pr.number,
                      title: pr.title,
                      url: pr.html_url,
                      author: pr.user?.login,
                      commits: []
                    });
                  }
                  prMap.get(pr.number).commits.push({
                    sha,
                    message: c.commit.message.split('\n')[0],
                    author: c.commit.author?.name || c.author?.login || 'unknown'
                  });
                }
              }
            }

            let md = `# Changelog (push to ${context.ref.replace('refs/heads/','')})\n\n`;
            md += `Commits in range **${base.substring(0,7)}..${head.substring(0,7)}**\n\n`;

            if (prMap.size === 0) {
              md += `*(No PR commits found in this push — likely direct commits or merge without PR association.)*\n`;
            } else {
              for (const [number, pr] of [...prMap.entries()].sort((a,b)=>a[0]-b[0])) {
                md += `## PR #${number}: ${pr.title} (by @${pr.author})\n`;
                md += `${pr.url}\n\n`;
                md += `**Commits:**\n`;
                for (const cc of pr.commits) {
                  md += `- ${cc.message} (${cc.sha.substring(0,7)}) — ${cc.author}\n`;
                }
                md += `\n`;
              }
            }

            core.setOutput('markdown', md);

      - name: Write CHANGELOG.md
        run: |
          echo "${{ steps.changelog.outputs.markdown }}" > CHANGELOG.md
          cat CHANGELOG.md

      - name: Commit changelog back (optional)
        run: |
          git add CHANGELOG.md
          git commit -m "chore: PR-only changelog for push ${{ github.sha }}"
          git push
